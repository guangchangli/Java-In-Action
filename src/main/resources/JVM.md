# JVM

1. ### 区域划分

   ![image-20200418174235655](picture-md/jvm.png)

   ``线程私有 虚拟机栈，本地方法栈，程序计数器``

   - #### 程序计数器

     ```
     线程私有
     存放当前线程字节码指令，字节码解释器通过改变程序计数器存的值，来选去下一条来执行的指令。
     流程控制，异常，跳转，线程恢复等功能都是通过计数器实现。
     线程私有，独自存储，可以保证多线程切换线程可以回到正常的位置，互不干扰。
     由于存放的是下一条指令地址，所以不会出现 oom
     ```

   - #### 栈

     ```
     虚拟机栈 线程私有，生命周期与线程相同。
     描述的是 java 方法执行的线程内存模型，每个方法执行会同步创建栈帧。
     存储 局部变量表，操作数栈，动态链接，方法出口。
     方法调用到执行完毕，对应一个栈帧在虚拟机栈中入栈到出栈过程
     ```

     ```
     局部变量表
     存放编译期间可知的基本数据类型、对象引用、returnAddress 类型（指向一条字节码指令）
     数据类型在局部变量表中的存储空间以局部变量槽（slot）表示，64 长度的 long 和 double 类型的数据会占用两个变量槽，其余数据类型只占用一个。
     局部变量表所需要的内存空间在编译器完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，运行期间不回改变局部变量表的大小（slot 数量）
     ```

     ```
     如果线程请求的栈深度大于虚 拟机所允许的深度，将抛出StackOverflowError异常;
     如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。
     Hotspot 不支持栈扩展,申请成功了就不会 oom
     ```

   - #### 堆

     ```
     线程共享，虚拟机启动创建，存放几乎所有对象实例和数组，物理不连续
     ```

   - #### 方法区（Meta-space）

     ```
     线程共享
     用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据
     jdk8 改用了本地内存实现元空间
     和堆一样，不连续存储，可以选择固定大小，可拓展，还可以选择不实现垃圾收集
     也可以进行垃圾回收，主要针对常量池和类型卸载
     低版本的 HotSpot 方法区可能会出现 oom
     ```

   - #### 运行时常量池

     ```
     方法区的一部分，class文件中除了有类似的版本、字段、方法、接口等信息，还有一部分是常量池
     用于存放编译期间生成的各种字面量与符号引用，类加载后存放到方法区的运行时常量池中
     ```

     ```
     动态性
     常量也可以运行时产生，可以在运行时放入
     String.intern()
     ```

     ```
     无法申请内存也会 oom
     ```

   - #### 直接内存

     ```
     会影响动态扩展 oom
     ```

2. ### HotSpot 对象

   1. #### 对象创建

