# JVM

1. 内存模型

   ​	``	区域划分``

   ![在这里插入图片描述](http://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKlgJOCN8LQa1s2wh2iaQd5hm0mlFicVH1jCqXMrhAGDN62zqfDkCUvI4xDOm0e5DYYHtH0seW0xAVMAg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

   ```
   程序计数器 
   程序计数器是内存中较小的一部分区域，是当前线程执行的字节码的行号指示器。在字节码解释器工作时通过计数器的值来选取下一条指令.
   多线程情况下，一条线程中有多个指令，为了使线程切换可以恢复到正确执行位置，每个线程都具有各自独立的程序计数器，所以该区域是非线程共享的内存区域。
   如果执行的是Java方法，计数器记录的是正在执行的字节码指令的地址；若执行的是Native方法，计数器存储为空。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域
   字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
   在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了
   ```

   ​	`方法区`

   ```
   方法区也称"永久代"，
   存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是各个线程共享的内存区域.
   永久代是一片连续的堆空间，在JVM启动之前通过在命令行设置参数-XX:MaxPermSize来设定永久代最大可分配的内存空间，默认大小是64M（64位JVM默认是85M）
   java虚拟机规范堆方法区限制非常的宽松，可以不选择垃圾回收，以及不需要连续的内存和可扩展的大小。这个区域主要是针对于常量池的回收以及对类型的卸载，当方法区无法分配到足够的内存的时候也会抛出OOM
   ```

   ​	``虚拟机栈``

   ```
   虚拟机栈是每个java方法的内存模型：每个方法被执行的时候都会创建一个"栈帧",用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程
   ```

   ​	``栈帧``

   ```
   局部变量表
   局部变量表所需要的空间在编译期完成分配，当执行一个方法时，该方法需要在栈帧中分配多大的局部变量表的空间完全是可以确定的，因此在方法运行的期间不会改变局部变量表的大小。
   局部变量表存放基本类型、对象的引用类型，在对象的引用类型中存储的是指向对象的地址
   当线程请求的栈深度大于虚拟机所允许的深度，就会抛出StackOverflowError异常。
   一般虚拟机的内存都是动态扩展的，但是有可能动态的扩展还是配不到足够的内存，就会抛出OOM异常
   操作数栈
   动态链接
   返回地址
   ```

   ```
   本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。
   本地方法栈为虚拟机使用到的native方法服务
   ```

   ​	`java堆`

   ```
   Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
   此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。堆内存是所有线程共有的，可以分为两个部分：年轻代和老年代
   Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)
   ```

2. ### 回收算法

   - #### 标记清除

     ```
     标记-清除是最基本的回收算法，后面的算法的设计的思想都是基于此算法进行设计。标记-清除算法一共分为两个阶段标记和清除阶段，标记阶段是将不可达的对象（即为不存活的对象）进行标记，接着清除阶段将这些标记的对象进行清除
     ```

     ```
     1.效率低
     2.会产生很多的内存碎片，大量的不连续内存空间，当程序需要申请较大的内存空间存储大对象的时候，有可能无法申请到足够的内存空间而不得不再一次触发一次垃圾回收动作
     ```

   - #### 复制算法

     ```
     复制算法将内存划分为两个区间
     在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间）
     而另外一个区间（称为空闲区间）则是空闲的。
     当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。
     接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。
     此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。
     ```

     ```
     复制算法比较适合用于存活率低的内存区域。它优化了标记/清除算法的效率和内存碎片问题
     ```

     ```
     老年代：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用标记-清理或标记-整理算法。整堆包括新生代和老年代的垃圾回收称为Full GC。
     ```

     ```
     永久代：主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间的区域。
     默认的Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即：Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小
     ```

   - #### 标记整理

     ```
     标记-整理算法也分为两步，首先标记不可达的对象，然后存活的对象往一端移动，然后直接清理掉端边界以外的内存。
     老年代中存活率比较高，要是使用复制算法，会大量浪费时间在复制对象上，因此复制算法不适合用在存活率比较高的场景
     ```

     ```
     标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。
     不难看出，标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。
     不过任何算法都会有其缺点，标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法
     ```

     