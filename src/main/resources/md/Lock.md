# Lock

``java 中的锁``





1. ### 锁分类

   - **乐观锁/悲观锁**
   - **独享锁/共享锁**
   - **互斥锁/读写锁**
   - **可重入锁**
   - **公平锁/非公平锁**
   - **分段锁**
   - **偏向锁/轻量级锁/重量级锁**
   - **自旋锁**
   - **分布式锁**

2. ### 乐观锁/悲观锁

   - **乐观锁**

     ```
     很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
     CAS atomic
     场景 读多
     ```

     ```update table set xxx=#{xxx}, version=version+1 where id=#{id} and version=#{version};```

   - **悲观锁**

     ```
     总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
     就是加锁，场景 写多
     ```

3. ### 独享锁/共享锁（AQS实现）

   - **独享锁**

     ```
     独享锁是指该锁一次只能被一个线程所持有。
     ReentrantLock 、Sync、ReadWriteLock写锁
     读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的
     ```

   - **共享锁**

     ```
     共享锁是指该锁可被多个线程所持有。
     ```

4. ### 互斥锁/读写锁（独享/共享 具体实现）

   - **互斥锁**

     ```
     ReentrantLock
     ```

   - **读写锁**

     ```
     ReadWriteLock
     ```

     

5. ### 可重入锁

   **可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁**

   ```
   ReetrantLock、sync 可在一定程度避免死锁
   ```

6. ### 公平锁/非公平锁

   ```
   对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
   对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。
   ```

   

   - **公平锁**

     ```
     公平锁是指多个线程按照申请锁的顺序来获取锁
     ```

   - **非公平锁**

     ```
     非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。
     ```

7. ### 分段锁

   ```
   分段锁是一种锁的设计，不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
   ConcurrentHashMap中的分段锁称为Segment，类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，
   内部拥有一个Entry数组，数组中的每个元素又是一个链表；
   同时又是一个ReentrantLock（Segment继承了ReentrantLock）。
   ```

   ```
   当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，
   当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
   但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
   分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。
   ```

8. ### 偏向锁/轻量级锁/重量级锁

   ```
   todo
   ```

9. ### 自旋转

   ```
   自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
   ```

   









